
    <section><h2>Single pages</h2>
<h4>/src/pages/example.js</h4>
<pre><code class="language-js">import { html } from 'orison';

export default context =&gt; html`
  ...
`
</code></pre>
</section>
    <section><h2>List pages</h2>
<h4>/src/pages/list.js</h4>
<pre><code class="language-js">import { html } from 'orison';

export default (context, slug) =&gt; [
  {
    name: 'path-segment-1',
    html: html`...`
  },
  {
    name: 'path-segment-2',
    html: html`...`
  }
  ...
]
</code></pre>
<p>In the below example we load in a list of blog posts with a made up loadContent
method. It is important to remember that when doing <code>orison build</code> the slug
parameter will be undefined and when doing <code>orison serve</code> it will be the last
path segment in the url. This way <code>orison serve</code> can only load in the data
it needs for the currently requested page and <code>orison build</code> can build every
page available from your content provider. This logic will need implemented
differently depending on what content provider you are using, and is hidden
inside the <code>loadContent</code> method in this example.</p>
<h4>/src/pages/list.js</h4>
<pre><code class="language-js">import { html } from 'orison';

export default async (context, slug) =&gt; {
  const blogPosts = await loadContent(slug);

  blogPosts.map(blogPost =&gt; ({
    name: blogPost.urlName,
    html: html`
      ...
    `
  );
}
</code></pre>
</section>
    <section><h2>Partials</h2>
<h4>/src/partials/example.js</h4>
<pre><code class="language-js">import { html } from 'orison';

export default data =&gt; html`
  ...
`
</code></pre>
</section>
    <section><h2>Layouts</h2>
<h4>/src/pages/layout.js</h4>
<pre><code class="language-js">import { html } from 'orison';

export default context =&gt; html`
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;OrisonJS&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;Website header&lt;/div&gt;
    ${context.page.html}
    &lt;div&gt;Website footer&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
`;
</code></pre>
</section>
    <section><h2>Context</h2>
<pre><code>context.path
context.data
context.local
context.parent
context.root
context.parents
context.children
context.mdString
context.mdFile
</code></pre>
<p>The local, parent, and root properties return <code>OrisonDirectory</code> objects. The
parents and children return arrays of <code>OrisonDirectory</code> objects.</p>
<h3>Child Directories</h3>
<p>The <code>context.local.children</code> property provides an array of <code>OrisonDirectory</code> objects
Each item in the array has the following attributes and methods:</p>
<p>These attributes give you access to the child data.json files, the
path of each child, and the <code>parent</code> and <code>children</code> methods can be used to
programmatically navigate the site structure.</p>
<p>The order of the children will be based on the <code>orison.order</code> property of the
corresponding data.json files as shown below.</p>
<h4>/src/pages/first/data.json</h4>
<pre><code class="language-json">{
  &quot;orison&quot;: {
    &quot;order&quot;: 100
  }
}
</code></pre>
<h4>/src/pages/second/data.json</h4>
<pre><code class="language-json">{
  &quot;orison&quot;: {
    &quot;order&quot;: 200
  }
}
</code></pre>
<p>In this example the &quot;first&quot; directory will be the first child in the array, and
the &quot;second&quot; directory will be the second child in the array. It is recommended
to use larger numbers so that you can reorder directories without having to
increment each directory.</p>
<p>This can then be used to create navigation elements as shown below. In this example
we are creating the navigation links by getting the children of the root directory.</p>
<h4>/src/pages/index.js</h4>
<pre><code class="language-js">const { html } = require('orison');

export default context =&gt; html`
  &lt;a href=&quot;/&quot; class=&quot;${context.page.path === '/index.js' ? 'active' : ''}&quot;&gt;Begin&lt;/a&gt;
  ${context.local.children.map(child =&gt; html`
    &lt;a href=&quot;${child.path}&quot;
       class=&quot;${context.page.path.startsWith(child.path) ? 'active' : ''}&quot;&gt;
       ${child.data.title}
    &lt;/a&gt;
  `)}
`;
</code></pre>
<h3>Root Directory</h3>
<pre><code class="language-js">export default context =&gt; html`
  ${context.root}
`
</code></pre>
<h3>Parent Directories</h3>
<pre><code class="language-js">export default context =&gt; html`
  ${context.parents}
`
</code></pre>
</section>
    <section><h2>Metadata</h2>
<p>Metadata file are data.json files under the /src/pages hierarchy. They are made
available to pages through the context API. The only restraint to the json file
is that &quot;orison&quot; is a reserved top level key:</p>
<h4>/src/pages/data.json</h4>
<pre><code class="language-json">{
  ...
  &quot;orison&quot;: {
    &quot;order&quot;: 100
  }
}
</code></pre>
<p>Currently the only supported key is the &quot;order&quot; key which determines the order
of the <code>getChildren()</code> context method.</p>
</section>
    <section><h2>Programatic Usage</h2>
<p>Instead of installing OrisonJS as a command line utility you can install it as a project dependency. Then you can interact with a configurable and programatic API for building and serving your site.</p>
<pre><code class="language-bash">npm install orison
</code></pre>
<p>You can require the CommonJS module from 'orison'.
ES6 Modules are available from './node_modules/orison/bin/orison-esm.js'</p>
<h3>Static site generation</h3>
<p>Here is an example of programmatically building the src directory into the docs directory.</p>
<pre><code class="language-js">const { OrisonGenerator } = require('orison');
const orisonGenerator = new OrisonGenerator({ rootPath: __dirname });
orisonGenerator.build();
</code></pre>
<h3>Static serving</h3>
<p>Here is an example of serving the statically built files.</p>
<pre><code class="language-js">const { OrisonStaticServer } = require('orison');
const orisonStaticServer = new OrisonStaticServer({ rootPath: __dirname });
orisonStaticServer.start();
</code></pre>
<h3>Server side generation</h3>
<p>Here is an example of serving files and rendering the file during each request.</p>
<pre><code class="language-js">const { OrisonServer } = require('orison');
const orisonServer = new OrisonServer({ rootPath: __dirname });
orisonServer.start();
</code></pre>
<h3>Custom command line utility</h3>
<p>Or you could create a file that builds, serves, or serves static based on provided command line arguments.</p>
<pre><code class="language-js">const { OrisonGenerator, OrisonServer, OrisonStaticServer } = require('orison');

if (process.argv.includes('build'))
  new OrisonGenerator({ rootPath: __dirname }).build();

if (process.argv.includes('serve'))
  new OrisonServer({ rootPath: __dirname }).start();

if (process.argv.includes('static'))
  new OrisonStaticServer({ rootPath: __dirname }).start();
</code></pre>
<p>Then you can build, serve, or serve static with these commands:</p>
<pre><code class="language-bash">node ./orison.js build
node ./orison.js serve
node ./orison.js static
</code></pre>
</section>
  